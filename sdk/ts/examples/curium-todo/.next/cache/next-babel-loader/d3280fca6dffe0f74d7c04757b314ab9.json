{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { bluzelle } from \"@bluzelle/sdk-js\";\nimport { extend } from 'lodash';\nimport { bluzelleConfig, userConfig } from \"../../example-config\";\nexport const params = bluzelleConfig;\nexport const userParams = userConfig;\nconst todosListeners = [];\nconst todos = {};\nconst bz = bluzelle(params);\nexport const initialLoadTodos = () => loadTodos();\nexport const onTodoListUpdated = fn => {\n  todosListeners.push(fn);\n};\nexport const storeTodo = todo => {\n  const time = new Date().toISOString();\n  todos[time] = _objectSpread({}, todo, {\n    time,\n    synced: false,\n    done: false\n  });\n  notifyListeners();\n\n  const storedTodo = _objectSpread({}, todo, {\n    time,\n    done: false\n  });\n\n  return bz.then(client => client.db.tx.Create({\n    creator: client.db.address,\n    // the creator of the transaction should always be the sender's address*\n    uuid: userConfig.uuid,\n    key: time,\n    value: new TextEncoder().encode(JSON.stringify(storedTodo)),\n    // values are stored as byte arrays \n    metadata: new Uint8Array(),\n    lease: {\n      days: 0,\n      seconds: 0,\n      years: 0,\n      hours: 1,\n      minutes: 0\n    } // Lease object to specify lifespan of key-value**\n\n  })).then(() => todos[time].synced = true).then(notifyListeners);\n};\n\nconst notifyListeners = () => todosListeners.forEach(listener => listener(Object.values(todos)));\n\nconst loadTodos = () => bz.then(client => client.db.q.KeyValues({\n  uuid: client.db.address\n})).then(result => result.keyValues.map(it => _objectSpread({}, JSON.parse(new TextDecoder().decode(it.value)), {\n  synced: true\n}))).then(list => list.map(it => todos[it.time] = extend(todos[it.time] || {}, it))).then(notifyListeners);\n\nexport const deleteTodo = todo => {\n  todo.synced = false;\n  notifyListeners();\n  return bz.then(client => client.db.tx.DeleteAll({\n    creator: client.db.address,\n    uuid: userConfig.uuid\n  })).then(() => delete todos[todo.time]).then(notifyListeners);\n};\nexport const toggleTodoDone = todo => {\n  todo.done = !todo.done;\n  todo.synced = false;\n  notifyListeners();\n  const storedTodo = {\n    done: todo.done,\n    body: todo.body,\n    time: todo.time\n  };\n  return bz.then(client => client.db.tx.Upsert({\n    creator: client.db.address,\n    uuid: userConfig.uuid,\n    key: todo.time,\n    value: new TextEncoder().encode(JSON.stringify(storedTodo)),\n    metadata: new Uint8Array(),\n    lease: {\n      days: 0,\n      seconds: 0,\n      years: 0,\n      hours: 1,\n      minutes: 0\n    }\n  })).then(() => todo.synced = true).then(notifyListeners);\n};","map":{"version":3,"sources":["/home/scott/work/bluzelle/curium/sdk/ts/examples/curium-todo/services/TodoService.ts"],"names":["bluzelle","extend","bluzelleConfig","userConfig","params","userParams","todosListeners","todos","bz","initialLoadTodos","loadTodos","onTodoListUpdated","fn","push","storeTodo","todo","time","Date","toISOString","synced","done","notifyListeners","storedTodo","then","client","db","tx","Create","creator","address","uuid","key","value","TextEncoder","encode","JSON","stringify","metadata","Uint8Array","lease","days","seconds","years","hours","minutes","forEach","listener","Object","values","q","KeyValues","result","keyValues","map","it","parse","TextDecoder","decode","list","deleteTodo","DeleteAll","toggleTodoDone","body","Upsert"],"mappings":"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","sourcesContent":["import {bluzelle} from \"@bluzelle/sdk-js\";\nimport {extend, memoize} from 'lodash'\nimport {StoredTodo, Todo} from \"../model/Todo\";\nimport {bluzelleConfig, userConfig} from \"../../example-config\";\n\nexport const params:any = bluzelleConfig;\nexport const userParams:any = userConfig;\n\nconst todosListeners = [];\nconst todos: Record<string, Todo> = {};\n\nconst bz = bluzelle(params);\n\nexport const initialLoadTodos = () => loadTodos();\n\nexport const onTodoListUpdated = (fn: (todos: Todo[]) => void) => {\n    todosListeners.push(fn);\n}\n\n\nexport const storeTodo = (todo: Pick<Todo, 'body'>): Promise<any> => {\n    const time = new Date().toISOString();\n    todos[time] = {...todo, time, synced: false, done: false};\n    notifyListeners();\n    const storedTodo: StoredTodo = {...todo, time, done: false};\n    return bz\n        .then(client => client.db.tx.Create({\t\n            creator: client.db.address,     \t\t\t// the creator of the transaction should always be the sender's address*\n            uuid: userConfig.uuid,\t\n            key: time,\n            value: new TextEncoder().encode(JSON.stringify(storedTodo)),\t// values are stored as byte arrays \n            metadata: new Uint8Array(),\t\t\t\n            lease: {days: 0, seconds: 0, years: 0, hours: 1, minutes: 0} // Lease object to specify lifespan of key-value**\n       }))\n        .then(() => todos[time].synced = true)\n        .then(notifyListeners)\n}\n\nconst notifyListeners = () =>\n todosListeners.forEach(listener => listener(Object.values(todos)));\n\nconst loadTodos = (): Promise<void> =>\n        bz\n        .then(client => client.db.q.KeyValues({uuid:client.db.address}))\n        .then(result => result.keyValues.map(it => ({...JSON.parse(new TextDecoder().decode(it.value)), synced: true})))\n        .then(list => list.map(it => todos[it.time] = extend(todos[it.time] || {},  it)))\n        .then(notifyListeners)\n\nexport const deleteTodo = (todo: Todo):Promise<any> => {\n    todo.synced = false;\n    notifyListeners();\n    return bz\n        .then(client => client.db.tx.DeleteAll({\n            creator: client.db.address,\n            uuid: userConfig.uuid\n        }))\n        .then(() => delete todos[todo.time])\n        .then(notifyListeners);\n}\n\nexport const toggleTodoDone = (todo: Todo): Promise<any> => {\n    todo.done = !todo.done;\n    todo.synced = false;\n    notifyListeners();\n    const storedTodo: StoredTodo = {\n        done: todo.done,\n        body: todo.body,\n        time: todo.time\n    }\n    return bz\n        .then(client => client.db.tx.Upsert({\n            creator: client.db.address,\n            uuid: userConfig.uuid,\n            key: todo.time,\n            value: new TextEncoder().encode(JSON.stringify(storedTodo)),\n            metadata: new Uint8Array(),\n            lease: {days: 0, seconds: 0, years: 0, hours: 1, minutes: 0} \n        }))\n        .then(() => todo.synced = true)\n        .then(notifyListeners)\n}\n\n\n"]},"metadata":{},"sourceType":"module"}